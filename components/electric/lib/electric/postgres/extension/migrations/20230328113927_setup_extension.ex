defmodule Electric.Postgres.Extension.Migrations.Migration_20230328113927 do
  alias Electric.Postgres.Extension

  @behaviour Extension.Migration

  @impl true
  def version, do: 2023_03_28_11_39_27

  def is_current_txid(prefix \\ ""),
    do: "#{prefix}txid = txid_current() AND #{prefix}txts = transaction_timestamp()"

  @impl true
  def up(schema) do
    ddl_table = Extension.ddl_table()
    schema_table = Extension.schema_table()
    version_table = Extension.version_table()

    [
      """
      CREATE TABLE #{version_table} (
          txid int8 NOT NULL,
          txts timestamp with time zone NOT NULL,
          version varchar(255) NOT NULL,
          PRIMARY KEY (txid, txts),
          CONSTRAINT "migration_unique_version" UNIQUE (version),
          CONSTRAINT "migration_unique_fk" UNIQUE (txid, txts, version)
      );
      """,
      ##################
      """
      CREATE TABLE #{ddl_table} (
          id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          txid int8 NOT NULL,
          txts timestamp with time zone NOT NULL,
          version varchar(255) NOT NULL,
          query text NOT NULL,
          FOREIGN KEY (txid, txts, version) REFERENCES #{version_table} (txid, txts, version)
      );
      """,
      ##################
      """
      CREATE TABLE #{schema_table} (
          id int8 NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          version varchar(255) NOT NULL,
          schema jsonb NOT NULL,
          created_at timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP
      );
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.migration_version(
          _v text,
          OUT txid int8,
          OUT txts timestamptz,
          OUT version text
      ) AS $function$
      DECLARE
          _version record;
      BEGIN
          INSERT INTO #{version_table} AS v
              (txid, txts, version) 
            VALUES
              (txid_current(), transaction_timestamp(), _v) 
            RETURNING v.txid, v.txts, v.version INTO txid, txts, version;
      END;
      $function$ LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.current_migration_version(
          OUT txid int8,
          OUT txts timestamptz,
          OUT version text
      ) AS $function$
      DECLARE
          _v text;
          _version record;
      BEGIN
          SELECT v.txid, v.txts, v.version 
              INTO txid, txts, version
              FROM #{version_table} v 
              WHERE #{is_current_txid("v.")} LIMIT 1;

          RAISE DEBUG 'got current version %', version;

          IF NOT FOUND THEN
            _v := (SELECT to_char(transaction_timestamp(), 'YYYYMMDDHH24MISS_FF3'));
            -- TODO: we should instead abort the transaction
            --       not doing that now because it would break everything
            RAISE WARNING 'assigning automatic migration version id: %', _v;
            SELECT v.txid, v.txts, v.version INTO txid, txts, version FROM #{schema}.migration_version(_v) v;
          END IF;
      END;
      $function$ LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.create_active_migration(_txid int8, _txts timestamptz, _version text) RETURNS int8 AS
      $function$
      DECLARE
          trid int8;
      BEGIN
          INSERT INTO #{ddl_table} (txid, txts, version, query) VALUES
                (_txid, _txts, _version, current_query())
              RETURNING id INTO trid;
          RETURN trid;
      END;
      $function$
      LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.active_migration_id() RETURNS int8 AS
      $function$
      DECLARE
          trid int8;
      BEGIN
      SELECT id INTO trid FROM #{ddl_table} WHERE #{is_current_txid()} ORDER BY id DESC LIMIT 1;
          RETURN trid;
      END;
      $function$
      LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.ddlx_command_start_handler()
      RETURNS EVENT_TRIGGER AS $function$
      DECLARE
          _txid int8;
          _txts timestamptz;
          _version text;
          trid int8;
      BEGIN
          SELECT v.txid, v.txts, v.version
            INTO _txid, _txts, _version
            FROM #{schema}.current_migration_version() v;

          RAISE DEBUG 'command_start_handler:: version: % :: start', _version;
          trid := (SELECT #{schema}.create_active_migration(_txid, _txts, _version));
          RAISE DEBUG 'command_start_handler:: version: % :: end', _version;
      END;
      $function$ LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE OR REPLACE FUNCTION #{schema}.ddlx_command_end_handler() RETURNS EVENT_TRIGGER AS
      $function$
      DECLARE
          _txid int8;
          _txts timestamptz;
          _version text;
          -- trid int8;
          -- v_cmd_rec record;
          -- do_insert_cmd boolean;
      BEGIN
          SELECT txid, txts, version
            INTO _txid, _txts, _version
            FROM #{schema}.current_migration_version();
          -- trid := (SELECT #{schema}.active_migration_id());
          RAISE DEBUG 'command_end_handler:: version: % :: start', _version;
          -- FOR v_cmd_rec IN SELECT * FROM pg_event_trigger_ddl_commands()
          -- LOOP
          --   do_insert_cmd := true;
          --   RAISE DEBUG 'command type %', v_cmd_rec.command_tag;

          --   IF v_cmd_rec.command_tag = 'CREATE TABLE' THEN
          --     RAISE DEBUG 'CREATE TABLE...';
          --   ELSIF v_cmd_rec.command_tag = 'CREATE INDEX' THEN
          --     RAISE DEBUG 'CREATE INDEX...';
          --   ELSIF v_cmd_rec.command_tag = 'ALTER TABLE' THEN
          --     IF EXISTS (SELECT 1 FROM pg_event_trigger_ddl_commands() WHERE objid = v_cmd_rec.objid AND command_tag = 'CREATE TABLE') THEN
          --       -- the table being altered is also being created in the same transaction. so we can just ignore this
          --       RAISE DEBUG 'CREATE + ALTER TABLE... %', v_cmd_rec.object_type;
          --       do_insert_cmd := false;
          --     ELSE
          --       RAISE DEBUG 'ALTER TABLE... %', v_cmd_rec.object_type;
          --     END IF;
          --   END IF;
          --   IF do_insert_cmd THEN
          --       INSERT INTO #{"@ddl_tbl"} (trid, trig, classid, objid, objsubid, command_tag, object_type, schema_name, object_identity)
          --       VALUES (
          --           trid,
          --           'e',
          --           v_cmd_rec.classid,
          --           v_cmd_rec.objid,
          --           v_cmd_rec.objsubid,
          --           v_cmd_rec.command_tag,
          --           v_cmd_rec.object_type,
          --           v_cmd_rec.schema_name,
          --           -- ARRAY[v_cmd_rec.object_identity]
          --           parse_ident(v_cmd_rec.object_identity)
          --       );
          --   END IF;

          -- END LOOP;
          RAISE DEBUG 'command_end_handler:: version: % :: end', _version;
      END;
      $function$
      LANGUAGE PLPGSQL;
      """,
      ##################
      """
      CREATE EVENT TRIGGER #{schema}_event_trigger_ddl_start ON ddl_command_start
          EXECUTE FUNCTION #{schema}.ddlx_command_start_handler();
      """,
      ##################
      """
      CREATE EVENT TRIGGER #{schema}_event_trigger_ddl_end ON ddl_command_end
          EXECUTE FUNCTION #{schema}.ddlx_command_end_handler();

      """
    ]
  end

  @impl true
  def down(_schema) do
    []
  end
end
